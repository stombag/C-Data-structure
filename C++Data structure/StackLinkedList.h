#pragma once

#include <iostream>
using namespace std;

class StackLinkedList
{
private:
	struct Node
	{
		int data;
		Node* next;
		Node(int value = 0) : data(value), next(nullptr) {};

	};

	Node* top;

public:
	StackLinkedList();
	~StackLinkedList();

	void push(int value);
	bool pop();
	int peek() const;
	bool isEmpty() const;
	void print() const;

};


// 장점 :
// 1. 공간의 제약 없음
// 배열은 크기를 미리 정해야하지만 연결리스트는 필요한때 마다 노드를 추가하므로 동적인 크기를 가질수있다. 
// 2. 삽입/삭제가 빠름 
// push,pop 연산이 모두 O(1)의 시간복잡도를 가진다.(맨앞에서만 작업하기 때문이다.)
// 3. 메모리 남비가 적음 
// 배열은 공간을 미리 할당하지만 연결 리스트는 필요한 만큼만 메모리 할당하므로 낭비가 적다.
// 4. 스택 오버플로우가 없음
// 배열은 최대 크기를 넘으면 오버플로우가 나지만, 연결 리스트는 메모리가 허용되는 한 무제한 push 가능하다.
// 
// 단점 : 
// 1. 메모리 사용량이 크다
// 각 노드는 데이터와 주소값도 저장해야 하므로 더 많은 메모리를 차지한다.
// 2. 연결 관리가 필요
// 노드를 직접 생성/삭제 하면서 포인터 다루어야하면 코드가 복잡하고 메모리 누수 위험이 있다.
// 3. 캐쉬 효율이 떨어진다.
// 배열은 연속된 메모리 공간이라 캐시 히트율이 높지만, 연결리스트는 분산 메모리 접근으로 인해 캐시 효율이 낮다.
// 4. 디버깅 어려움
// 포인터 버그는 추적이 어렵고 프로그램이 비정상 종료될 가능성이 높다. 
// 
// 사용 예시 : 
// 1. 인벤토리 아이템 저장 (앞에서부터 넣기) 
// 2. 행동 명령 저장 (사용자가 저장한 행동를 하나씩 꺼내서 실행-취소하기)
// 3. 공격 히스토리 관리(공격 순서를 저장하고 넣기) 
//
// 스택 연결 리스트가 유리한 상황
// 스택의 크기가 예측하기 힘들때와 자주 크기를 조절할때가 사용하기 좋다
