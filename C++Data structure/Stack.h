#pragma once
class Stack
{
private:
	int* arr;// 스택 배열 
	int capacity; // 최대 크기
	int top;// top 인덱스

public:
	Stack(int size = 100); // 생성자 
	~Stack(); // 소멸자
	void push(int value);// 값을 넣기
	bool pop(int& result);// 값을 꺼내고 지우기
	bool peek(int& result) const;// 맨위의 값을 보기
	bool isEmpty() const;// 비어있는지 확인
	bool isFull()const; // 꽉 찼는지 확인 
	void print() const;// 스택 출력 






};
// 장점 :
// 1.접근 속도가 매우 빠르다
// 인데스로 바로  접근할 수 있어 O(1) 시간에 데이터를 꺼낼 수 있다.
// 2. 연속된 메모리 배치
// CPU 캐쉬 친화적이라 반복 처리 속도가 빠르다. 
// 3. 구현이 단순하다.
// 포인터나 동적 메모리 관리 없이 쉽게 만들 수 있다. 
// 4. 메모리 오버헤드가 적음 
// 포인터를 저장할 필요가 없어 연결 리스트보다 메모리 사용량이 적습니다. 

// 단점 : 
// 1. 크기를 미리 정해야 하며
// 스택이 꽉차면 더 이상 데이터를 push할 수 없다.
// 2. 메모리 낭비 가능성 
// 너무 크게 만들면  사용하지 않는 공간이 생겨 낭비된다. 
// 3. 삽입/삭제 유연성이 낮음 
// 중간에 데이터를 넣거나 빼기 어렵고 전체 이동이 필요하다. 
// 4. 크기 확장이 어렵다.
// 크기를 바꾸려면 새 배열을 만들고 데이터를 복사해야 해서 번거롭습니다. 

// 사용 예시 
// 1. 총알 풀 관리
// 2. UI 입력 기록 저장
// 3. 애니메이션 프레임 처리
// 4. 간단한  Undo 기능
// 5. 미니게임 수식 계산기 
// 6. 게임 상태 백업 및 복구 

// 배열 스택이 하기 좋은 상황
// 크기가 작고 고정된 데이터를 다룰때(키 입력 스택, 임시 버퍼==임시로 데이터를 저장하는곳)